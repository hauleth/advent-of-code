<!-- vim: syntax=markdown -->
<!-- livebook:{"persist_outputs":true} -->

# Advent of Code 2021

## Setup

```elixir
Mix.install([])
```

```output
:ok
```

## Day 1

### Load input

```elixir
stream =
  File.stream!("day1.txt")
  |> Stream.map(&String.to_integer(String.trim(&1)))
```

```output
#Stream<[
  enum: %File.Stream{
    line_or_bytes: :line,
    modes: [:raw, :read_ahead, :binary],
    path: "day1.txt",
    raw: true
  },
  funs: [#Function<47.58486609/1 in Stream.map/2>]
]>
```

### Task 1

<!-- livebook:{"break_markdown":true} -->

Compute count of consecutive increases

```elixir
stream
|> Stream.chunk_every(2, 1, :discard)
|> Enum.count(fn [a, b] -> a < b end)
```

```output
1688
```

### Task 2

<!-- livebook:{"break_markdown":true} -->

Compute count of consecutive increases of sums of trigrams.

However we can notice, that if we have list like:

$$
[a, b, c, d]
$$

Then when we want to compare consecutive trigrams then we compare:

$$
a + b + c < b + c + d \\
a < d
$$

So we can traverse each 4 elements and then just compare first and last one
instead of summing and then traversing it again.

```elixir
stream
|> Stream.chunk_every(4, 1, :discard)
|> Enum.count(fn [a, _, _, b] -> a < b end)
```

```output
1728
```

## Day 2

### Load input

We do parsing there, as it will help us with the latter tasks. Pattern matching
is the simplest approach there, as input is in form of:

```
forward 10
up 20
down 30
```

We need to `trim/1` input to make sure that the last newline will not interrupt
`String.to_integer/1` calls.

```elixir
stream =
  File.stream!("day2.txt")
  |> Stream.map(fn input ->
    case String.trim(input) do
      "forward " <> n -> {:forward, String.to_integer(n)}
      "up " <> n -> {:up, String.to_integer(n)}
      "down " <> n -> {:down, String.to_integer(n)}
    end
  end)
```

```output
#Stream<[
  enum: %File.Stream{
    line_or_bytes: :line,
    modes: [:raw, :read_ahead, :binary],
    path: "day2.txt",
    raw: true
  },
  funs: [#Function<47.58486609/1 in Stream.map/2>]
]>
```

### Task 1

```elixir
{h, d} =
  stream
  |> Enum.reduce({0, 0}, fn
    {:forward, n}, {h, d} -> {h + n, d}
    {:up, n}, {h, d} -> {h, d - n}
    {:down, n}, {h, d} -> {h, d + n}
  end)

h * d
```

```output
1499229
```

### Task 2

```elixir
{h, d, _} =
  stream
  |> Enum.reduce({0, 0, 0}, fn
    {:forward, n}, {h, d, a} -> {h + n, d + a * n, a}
    {:up, n}, {h, d, a} -> {h, d, a - n}
    {:down, n}, {h, d, a} -> {h, d, a + n}
  end)

h * d
```

```output
1340836560
```

## Day 3

### Input

```elixir
stream =
  File.stream!("day3.txt")
  |> Enum.map(&String.trim/1)
  |> Enum.map(&String.to_charlist/1)

defmodule Day3 do
  def count(list) do
    Enum.reduce(list, List.duplicate(0, 12), fn input, acc ->
      for {value, counter} <- Enum.zip(input, acc) do
        case value do
          ?1 -> counter + 1
          ?0 -> counter
        end
      end
    end)
  end
end
```

```output
{:module, Day3, <<70, 79, 82, 49, 0, 0, 7, ...>>, {:count, 1}}
```

### Task 1

```elixir
half = div(length(stream), 2)

{a, b} =
  stream
  |> Day3.count()
  |> Enum.reduce({0, 0}, fn elem, {a, b} ->
    if elem > half do
      {a * 2 + 1, b * 2}
    else
      {a * 2, b * 2 + 1}
    end
  end)

a * b
```

```output
3847100
```

### Task 2

```elixir
defmodule Day3.Task2 do
  def reduce(list, cb), do: reduce(list, 0, cb)

  defp reduce([elem], _, _), do: elem

  defp reduce(list, at, cb) do
    counts = Day3.count(list)

    half = div(length(list), 2)
    count = Enum.at(counts, at)

    bit =
      cond do
        count == half and cb.(count + 1, half) -> ?1
        count != half and cb.(count, half) -> ?1
        true -> ?0
      end

    reduce(Enum.filter(list, &(Enum.at(&1, at) == bit)), at + 1, cb)
  end
end

co2 = List.to_integer(Day3.Task2.reduce(stream, &</2), 2)
o2 = List.to_integer(Day3.Task2.reduce(stream, &>/2), 2)

co2 * o2
```

```output
4105235
```
